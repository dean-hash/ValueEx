import * as THREE from 'three';
import { ResonantInterface, ResonanceGesture, ResonanceField, ResonancePoint, ResonanceEvent } from '../interfaces/resonantInterface';
interface ValueSignal {
    type: 'opportunity';
    strength: number;
    resonancePattern: ResonanceField;
    probability: number;
    timeToValue: number;
    estimatedValue: number;
    requirements: string[];
    actionPath: string[];
}
export declare class ResonanceGestures implements ResonantInterface {
    private canvas;
    private gestureFields;
    private intentionField;
    private resonanceStrength;
    private scene;
    private camera;
    private renderer;
    private valueOpportunities;
    private opportunityHandler;
    constructor(canvas: HTMLCanvasElement);
    private initializeScene;
    private initializeGestureField;
    private updateGestureField;
    private createEmergentPattern;
    private createQuantumWave;
    private createEntangledSpiral;
    private createSuperpositionPulse;
    private createResonanceFlow;
    createField(center: THREE.Vector3, radius: number): ResonanceField;
    addPoint(field: ResonanceField, point: ResonancePoint): void;
    removePoint(field: ResonanceField, point: ResonancePoint): void;
    initiateGesture(gesture: ResonanceGesture): void;
    completeGesture(gesture: ResonanceGesture): void;
    processEvent(event: ResonanceEvent): void;
    harmonize(field: ResonanceField): void;
    amplify(point: ResonancePoint, factor: number): void;
    dissolve(field: ResonanceField): void;
    render(): void;
    update(deltaTime: number): void;
    emitValueSignal(signal: ValueSignal): void;
    detectValuePatterns(field: ResonanceField): ValueSignal[];
    amplifyValueSignal(signal: ValueSignal): Promise<number>;
    transformValueToAction(signal: ValueSignal): Promise<void>;
    private createWaveGesture;
    private createSpiralGesture;
    private createPulseGesture;
    private createFlowGesture;
    private updateFieldHarmonics;
    private handleInitiation;
    private handleAmplification;
    private handleHarmonization;
    private handleDissolution;
    private calculateValueColor;
    private determineOpportunityType;
    private calculatePotentialPaths;
    private animatePulse;
    private emitValueOpportunity;
    private visualizeOpportunity;
}
export {};
